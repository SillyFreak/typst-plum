use std::collections::BTreeMap;
use std::str::FromStr;

use either::Either;
use lalrpop_util::ParseError;

use crate::model::*;
use super::from_mark;

grammar;

pub Diagram: Diagram<'input> = {
    "\n"* <mut items: (<ClassifierOrEdge> "\n"+)*> <item: ClassifierOrEdge?> => {
        items.extend(item);
        let mut classifiers = Vec::new();
        let mut edges = Vec::new();
        for item in items {
            match item {
                Either::Left(item) => classifiers.push(item),
                Either::Right(item) => edges.push(item),
            }
        }
        Diagram { classifiers, edges }
    }
}

ClassifierOrEdge: Either<Classifier<'input>, Edge<'input>> = {
    Classifier => Either::Left(<>),
    Edge => Either::Right(<>),
}

Classifier: Classifier<'input> = {
    <meta: Metas>
    <is_abstract: "abstract"?> <is_final: "final"?> <kind: ClassifierKind> <name: Name> <id: ("as" <Name>)?> <body: ClassifierBody> => {
        let (kind, stereotype) = kind;
        let is_abstract = is_abstract.is_some() || kind == ClassifierKind::Interface;
        let is_final = is_final.is_some();
        let mut stereotypes = Vec::new();
        stereotypes.extend(stereotype);
        let attributes = body;
        Classifier { meta, is_abstract, is_final, kind, name, id, stereotypes, attributes }
    }
}

ClassifierBody: Vec<Attribute<'input>> = {
    => Vec::new(),
    "{" "\n"* "}" => Vec::new(),
    "{" "\n"+ <attrs: (<Attribute> "\n"+)+> "}" => attrs,
}

Attribute: Attribute<'input> = {
    <visibility: Visibility?> <name: Name> => {
        let r#type = None;
        Attribute { visibility, name, r#type }
    }
}

Edge: Edge<'input> = {
    <a: Name> <kind: EdgeKind> <b: Name> => Edge { a, b, kind }
}

EdgeKind: EdgeKind<'input> = {
    "..|>" => EdgeKind::Realization { direction: Direction::AToB },
    "<|.." => EdgeKind::Realization { direction: Direction::BToA },
    "--|>" => EdgeKind::Generalization { direction: Direction::AToB },
    "<|--" => EdgeKind::Generalization { direction: Direction::BToA },
    "..>" => EdgeKind::Dependency { direction: Direction::AToB, name: None },
    "<.." => EdgeKind::Dependency { direction: Direction::BToA, name: None },
    r"([<x]|[o*]?(-x)?)--((x-)?[o*]?|[x>])" => {
        let (a, b) = {
            let mut iter = <>.split("--");
            let a = iter.next().unwrap();
            let b = iter.next().unwrap();
            assert!(iter.next().is_none());
            (from_mark(a), from_mark(b))
        };
        EdgeKind::Association { name: None, a, b }
    },
}

Visibility: Visibility = {
    "-" => Visibility::Private,
    "~" => Visibility::Package,
    "#" => Visibility::Protected,
    "+" => Visibility::Public,
}

Metas: BTreeMap<&'input str, Meta> = {
    "#[" <mut attrs: (<Meta> ",")*> <attr: (<Meta> ","?)> "]" "\n"* => {
        attrs.push(attr);
        BTreeMap::from_iter(attrs.into_iter().map(|attr| (attr.name(), attr)))
    },
    => BTreeMap::new(),
}

Meta: Meta = {
    "pos" "(" <Num> "," <Num> ")" => Meta::Position(<>),
}

ClassifierKind: (ClassifierKind, Option<&'input str>) = {
    "class" => (ClassifierKind::Class, None),
    "dataType" => (ClassifierKind::DataType, None),
    "enumeration" => (ClassifierKind::Enumeration, None),
    "interface" => (ClassifierKind::Interface, None),
    "primitive" => (ClassifierKind::Primitive, None),
    "annotation" => (ClassifierKind::Interface, Some(<>)),
    "exception" => (ClassifierKind::Class, Some(<>)),
    "struct" => (ClassifierKind::Class, Some(<>)),
}

Num: isize = {
    r"[-+]?\d+" =>? isize::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number is too big"
        })
}

Name: &'input str = {
    r"[_\p{ID_Start}][_\p{ID_Continue}-]*"
}

match {
    r"[\s&&[^\r\n]]*" => { }, // don't allow random newlines
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    r"([<x]|[o*]?(-x)?)--((x-)?[o*]?|[x>])",
} else {
    r"[_\p{ID_Start}][_\p{ID_Continue}-]*",
    _
}
